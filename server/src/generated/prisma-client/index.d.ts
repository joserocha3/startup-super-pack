// Code generated by Prisma (prisma@1.20.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode, GraphQLSchema } from "graphql";
import { makePrismaClientClass, BaseClientOptions } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  crossing: (where?: CrossingWhereInput) => Promise<boolean>;
  geofence: (where?: GeofenceWhereInput) => Promise<boolean>;
  redemption: (where?: RedemptionWhereInput) => Promise<boolean>;
  reward: (where?: RewardWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  crossing: (where: CrossingWhereUniqueInput) => CrossingPromise;
  crossings: (
    args?: {
      where?: CrossingWhereInput;
      orderBy?: CrossingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Crossing>;
  crossingsConnection: (
    args?: {
      where?: CrossingWhereInput;
      orderBy?: CrossingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CrossingConnectionPromise;
  geofences: (
    args?: {
      where?: GeofenceWhereInput;
      orderBy?: GeofenceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Geofence>;
  geofencesConnection: (
    args?: {
      where?: GeofenceWhereInput;
      orderBy?: GeofenceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GeofenceConnectionPromise;
  redemptions: (
    args?: {
      where?: RedemptionWhereInput;
      orderBy?: RedemptionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Redemption>;
  redemptionsConnection: (
    args?: {
      where?: RedemptionWhereInput;
      orderBy?: RedemptionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RedemptionConnectionPromise;
  rewards: (
    args?: {
      where?: RewardWhereInput;
      orderBy?: RewardOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Reward>;
  rewardsConnection: (
    args?: {
      where?: RewardWhereInput;
      orderBy?: RewardOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RewardConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCrossing: (data: CrossingCreateInput) => CrossingPromise;
  updateCrossing: (
    args: { data: CrossingUpdateInput; where: CrossingWhereUniqueInput }
  ) => CrossingPromise;
  updateManyCrossings: (
    args: { data: CrossingUpdateManyMutationInput; where?: CrossingWhereInput }
  ) => BatchPayloadPromise;
  upsertCrossing: (
    args: {
      where: CrossingWhereUniqueInput;
      create: CrossingCreateInput;
      update: CrossingUpdateInput;
    }
  ) => CrossingPromise;
  deleteCrossing: (where: CrossingWhereUniqueInput) => CrossingPromise;
  deleteManyCrossings: (where?: CrossingWhereInput) => BatchPayloadPromise;
  createGeofence: (data: GeofenceCreateInput) => GeofencePromise;
  updateManyGeofences: (
    args: { data: GeofenceUpdateManyMutationInput; where?: GeofenceWhereInput }
  ) => BatchPayloadPromise;
  deleteManyGeofences: (where?: GeofenceWhereInput) => BatchPayloadPromise;
  createRedemption: (data: RedemptionCreateInput) => RedemptionPromise;
  updateManyRedemptions: (
    args: {
      data: RedemptionUpdateManyMutationInput;
      where?: RedemptionWhereInput;
    }
  ) => BatchPayloadPromise;
  deleteManyRedemptions: (where?: RedemptionWhereInput) => BatchPayloadPromise;
  createReward: (data: RewardCreateInput) => RewardPromise;
  updateManyRewards: (
    args: { data: RewardUpdateManyMutationInput; where?: RewardWhereInput }
  ) => BatchPayloadPromise;
  deleteManyRewards: (where?: RewardWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  crossing: (
    where?: CrossingSubscriptionWhereInput
  ) => CrossingSubscriptionPayloadSubscription;
  geofence: (
    where?: GeofenceSubscriptionWhereInput
  ) => GeofenceSubscriptionPayloadSubscription;
  redemption: (
    where?: RedemptionSubscriptionWhereInput
  ) => RedemptionSubscriptionPayloadSubscription;
  reward: (
    where?: RewardSubscriptionWhereInput
  ) => RewardSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type UserRole = "ADMIN" | "MANAGER" | "CLIENT" | "APP_USER";

export type RedemptionOrderByInput =
  | "awardedAt_ASC"
  | "awardedAt_DESC"
  | "points_ASC"
  | "points_DESC"
  | "reward_ASC"
  | "reward_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GeofenceOrderByInput =
  | "radius_ASC"
  | "radius_DESC"
  | "description_ASC"
  | "description_DESC"
  | "title_ASC"
  | "title_DESC"
  | "coordinates_ASC"
  | "coordinates_DESC"
  | "status_ASC"
  | "status_DESC"
  | "type_ASC"
  | "type_DESC"
  | "points_ASC"
  | "points_DESC"
  | "refreshRate_ASC"
  | "refreshRate_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CrossingOrderByInput =
  | "crossedIn_ASC"
  | "crossedIn_DESC"
  | "crossedOut_ASC"
  | "crossedOut_DESC"
  | "geofence_ASC"
  | "geofence_DESC"
  | "coordinates_ASC"
  | "coordinates_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RewardOrderByInput =
  | "points_ASC"
  | "points_DESC"
  | "title_ASC"
  | "title_DESC"
  | "text_ASC"
  | "text_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "authId_ASC"
  | "authId_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "role_ASC"
  | "role_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type CrossingWhereUniqueInput = AtLeastOne<{
  coordinates: String;
}>;

export interface RedemptionWhereInput {
  awardedAt?: DateTimeInput;
  awardedAt_not?: DateTimeInput;
  awardedAt_in?: DateTimeInput[] | DateTimeInput;
  awardedAt_not_in?: DateTimeInput[] | DateTimeInput;
  awardedAt_lt?: DateTimeInput;
  awardedAt_lte?: DateTimeInput;
  awardedAt_gt?: DateTimeInput;
  awardedAt_gte?: DateTimeInput;
  points?: Float;
  points_not?: Float;
  points_in?: Float[] | Float;
  points_not_in?: Float[] | Float;
  points_lt?: Float;
  points_lte?: Float;
  points_gt?: Float;
  points_gte?: Float;
  redeemer?: UserWhereInput;
  reward?: String;
  reward_not?: String;
  reward_in?: String[] | String;
  reward_not_in?: String[] | String;
  reward_lt?: String;
  reward_lte?: String;
  reward_gt?: String;
  reward_gte?: String;
  reward_contains?: String;
  reward_not_contains?: String;
  reward_starts_with?: String;
  reward_not_starts_with?: String;
  reward_ends_with?: String;
  reward_not_ends_with?: String;
  AND?: RedemptionWhereInput[] | RedemptionWhereInput;
  OR?: RedemptionWhereInput[] | RedemptionWhereInput;
  NOT?: RedemptionWhereInput[] | RedemptionWhereInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  authId?: String;
  authId_not?: String;
  authId_in?: String[] | String;
  authId_not_in?: String[] | String;
  authId_lt?: String;
  authId_lte?: String;
  authId_gt?: String;
  authId_gte?: String;
  authId_contains?: String;
  authId_not_contains?: String;
  authId_starts_with?: String;
  authId_not_starts_with?: String;
  authId_ends_with?: String;
  authId_not_ends_with?: String;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  role?: UserRole;
  role_not?: UserRole;
  role_in?: UserRole[] | UserRole;
  role_not_in?: UserRole[] | UserRole;
  redemptions_every?: RedemptionWhereInput;
  redemptions_some?: RedemptionWhereInput;
  redemptions_none?: RedemptionWhereInput;
  geofences_every?: GeofenceWhereInput;
  geofences_some?: GeofenceWhereInput;
  geofences_none?: GeofenceWhereInput;
  crossings_every?: CrossingWhereInput;
  crossings_some?: CrossingWhereInput;
  crossings_none?: CrossingWhereInput;
  rewards_every?: RewardWhereInput;
  rewards_some?: RewardWhereInput;
  rewards_none?: RewardWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface GeofenceWhereInput {
  radius?: Float;
  radius_not?: Float;
  radius_in?: Float[] | Float;
  radius_not_in?: Float[] | Float;
  radius_lt?: Float;
  radius_lte?: Float;
  radius_gt?: Float;
  radius_gte?: Float;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  coordinates?: String;
  coordinates_not?: String;
  coordinates_in?: String[] | String;
  coordinates_not_in?: String[] | String;
  coordinates_lt?: String;
  coordinates_lte?: String;
  coordinates_gt?: String;
  coordinates_gte?: String;
  coordinates_contains?: String;
  coordinates_not_contains?: String;
  coordinates_starts_with?: String;
  coordinates_not_starts_with?: String;
  coordinates_ends_with?: String;
  coordinates_not_ends_with?: String;
  status?: String;
  status_not?: String;
  status_in?: String[] | String;
  status_not_in?: String[] | String;
  status_lt?: String;
  status_lte?: String;
  status_gt?: String;
  status_gte?: String;
  status_contains?: String;
  status_not_contains?: String;
  status_starts_with?: String;
  status_not_starts_with?: String;
  status_ends_with?: String;
  status_not_ends_with?: String;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  points?: Int;
  points_not?: Int;
  points_in?: Int[] | Int;
  points_not_in?: Int[] | Int;
  points_lt?: Int;
  points_lte?: Int;
  points_gt?: Int;
  points_gte?: Int;
  refreshRate?: Float;
  refreshRate_not?: Float;
  refreshRate_in?: Float[] | Float;
  refreshRate_not_in?: Float[] | Float;
  refreshRate_lt?: Float;
  refreshRate_lte?: Float;
  refreshRate_gt?: Float;
  refreshRate_gte?: Float;
  owner?: UserWhereInput;
  AND?: GeofenceWhereInput[] | GeofenceWhereInput;
  OR?: GeofenceWhereInput[] | GeofenceWhereInput;
  NOT?: GeofenceWhereInput[] | GeofenceWhereInput;
}

export interface CrossingWhereInput {
  crossedIn?: DateTimeInput;
  crossedIn_not?: DateTimeInput;
  crossedIn_in?: DateTimeInput[] | DateTimeInput;
  crossedIn_not_in?: DateTimeInput[] | DateTimeInput;
  crossedIn_lt?: DateTimeInput;
  crossedIn_lte?: DateTimeInput;
  crossedIn_gt?: DateTimeInput;
  crossedIn_gte?: DateTimeInput;
  crossedOut?: DateTimeInput;
  crossedOut_not?: DateTimeInput;
  crossedOut_in?: DateTimeInput[] | DateTimeInput;
  crossedOut_not_in?: DateTimeInput[] | DateTimeInput;
  crossedOut_lt?: DateTimeInput;
  crossedOut_lte?: DateTimeInput;
  crossedOut_gt?: DateTimeInput;
  crossedOut_gte?: DateTimeInput;
  geofence?: ID_Input;
  geofence_not?: ID_Input;
  geofence_in?: ID_Input[] | ID_Input;
  geofence_not_in?: ID_Input[] | ID_Input;
  geofence_lt?: ID_Input;
  geofence_lte?: ID_Input;
  geofence_gt?: ID_Input;
  geofence_gte?: ID_Input;
  geofence_contains?: ID_Input;
  geofence_not_contains?: ID_Input;
  geofence_starts_with?: ID_Input;
  geofence_not_starts_with?: ID_Input;
  geofence_ends_with?: ID_Input;
  geofence_not_ends_with?: ID_Input;
  coordinates?: String;
  coordinates_not?: String;
  coordinates_in?: String[] | String;
  coordinates_not_in?: String[] | String;
  coordinates_lt?: String;
  coordinates_lte?: String;
  coordinates_gt?: String;
  coordinates_gte?: String;
  coordinates_contains?: String;
  coordinates_not_contains?: String;
  coordinates_starts_with?: String;
  coordinates_not_starts_with?: String;
  coordinates_ends_with?: String;
  coordinates_not_ends_with?: String;
  crosser?: UserWhereInput;
  AND?: CrossingWhereInput[] | CrossingWhereInput;
  OR?: CrossingWhereInput[] | CrossingWhereInput;
  NOT?: CrossingWhereInput[] | CrossingWhereInput;
}

export interface RewardWhereInput {
  points?: Float;
  points_not?: Float;
  points_in?: Float[] | Float;
  points_not_in?: Float[] | Float;
  points_lt?: Float;
  points_lte?: Float;
  points_gt?: Float;
  points_gte?: Float;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  grantor?: UserWhereInput;
  AND?: RewardWhereInput[] | RewardWhereInput;
  OR?: RewardWhereInput[] | RewardWhereInput;
  NOT?: RewardWhereInput[] | RewardWhereInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
  authId?: String;
}>;

export interface CrossingCreateInput {
  crossedIn?: DateTimeInput;
  crossedOut?: DateTimeInput;
  geofence?: ID_Input;
  coordinates?: String;
  crosser?: UserCreateOneWithoutCrossingsInput;
}

export interface UserCreateOneWithoutCrossingsInput {
  create?: UserCreateWithoutCrossingsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutCrossingsInput {
  email: String;
  authId?: String;
  firstName: String;
  lastName: String;
  role: UserRole;
  redemptions?: RedemptionCreateManyWithoutRedeemerInput;
  geofences?: GeofenceCreateManyWithoutOwnerInput;
  rewards?: RewardCreateManyWithoutGrantorInput;
}

export interface RedemptionCreateManyWithoutRedeemerInput {
  create?:
    | RedemptionCreateWithoutRedeemerInput[]
    | RedemptionCreateWithoutRedeemerInput;
}

export interface RedemptionCreateWithoutRedeemerInput {
  awardedAt?: DateTimeInput;
  points?: Float;
  reward?: String;
}

export interface GeofenceCreateManyWithoutOwnerInput {
  create?: GeofenceCreateWithoutOwnerInput[] | GeofenceCreateWithoutOwnerInput;
}

export interface GeofenceCreateWithoutOwnerInput {
  radius?: Float;
  description?: String;
  title?: String;
  coordinates?: String;
  status?: String;
  type?: String;
  points?: Int;
  refreshRate?: Float;
}

export interface RewardCreateManyWithoutGrantorInput {
  create?: RewardCreateWithoutGrantorInput[] | RewardCreateWithoutGrantorInput;
}

export interface RewardCreateWithoutGrantorInput {
  points?: Float;
  title?: String;
  text?: String;
}

export interface CrossingUpdateInput {
  crossedIn?: DateTimeInput;
  crossedOut?: DateTimeInput;
  geofence?: ID_Input;
  coordinates?: String;
  crosser?: UserUpdateOneWithoutCrossingsInput;
}

export interface UserUpdateOneWithoutCrossingsInput {
  create?: UserCreateWithoutCrossingsInput;
  update?: UserUpdateWithoutCrossingsDataInput;
  upsert?: UserUpsertWithoutCrossingsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutCrossingsDataInput {
  email?: String;
  authId?: String;
  firstName?: String;
  lastName?: String;
  role?: UserRole;
  redemptions?: RedemptionUpdateManyWithoutRedeemerInput;
  geofences?: GeofenceUpdateManyWithoutOwnerInput;
  rewards?: RewardUpdateManyWithoutGrantorInput;
}

export interface RedemptionUpdateManyWithoutRedeemerInput {
  create?:
    | RedemptionCreateWithoutRedeemerInput[]
    | RedemptionCreateWithoutRedeemerInput;
}

export interface GeofenceUpdateManyWithoutOwnerInput {
  create?: GeofenceCreateWithoutOwnerInput[] | GeofenceCreateWithoutOwnerInput;
}

export interface RewardUpdateManyWithoutGrantorInput {
  create?: RewardCreateWithoutGrantorInput[] | RewardCreateWithoutGrantorInput;
}

export interface UserUpsertWithoutCrossingsInput {
  update: UserUpdateWithoutCrossingsDataInput;
  create: UserCreateWithoutCrossingsInput;
}

export interface CrossingUpdateManyMutationInput {
  crossedIn?: DateTimeInput;
  crossedOut?: DateTimeInput;
  geofence?: ID_Input;
  coordinates?: String;
}

export interface GeofenceCreateInput {
  radius?: Float;
  description?: String;
  title?: String;
  coordinates?: String;
  status?: String;
  type?: String;
  points?: Int;
  refreshRate?: Float;
  owner?: UserCreateOneWithoutGeofencesInput;
}

export interface UserCreateOneWithoutGeofencesInput {
  create?: UserCreateWithoutGeofencesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutGeofencesInput {
  email: String;
  authId?: String;
  firstName: String;
  lastName: String;
  role: UserRole;
  redemptions?: RedemptionCreateManyWithoutRedeemerInput;
  crossings?: CrossingCreateManyWithoutCrosserInput;
  rewards?: RewardCreateManyWithoutGrantorInput;
}

export interface CrossingCreateManyWithoutCrosserInput {
  create?:
    | CrossingCreateWithoutCrosserInput[]
    | CrossingCreateWithoutCrosserInput;
  connect?: CrossingWhereUniqueInput[] | CrossingWhereUniqueInput;
}

export interface CrossingCreateWithoutCrosserInput {
  crossedIn?: DateTimeInput;
  crossedOut?: DateTimeInput;
  geofence?: ID_Input;
  coordinates?: String;
}

export interface GeofenceUpdateManyMutationInput {
  radius?: Float;
  description?: String;
  title?: String;
  coordinates?: String;
  status?: String;
  type?: String;
  points?: Int;
  refreshRate?: Float;
}

export interface RedemptionCreateInput {
  awardedAt?: DateTimeInput;
  points?: Float;
  redeemer?: UserCreateOneWithoutRedemptionsInput;
  reward?: String;
}

export interface UserCreateOneWithoutRedemptionsInput {
  create?: UserCreateWithoutRedemptionsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutRedemptionsInput {
  email: String;
  authId?: String;
  firstName: String;
  lastName: String;
  role: UserRole;
  geofences?: GeofenceCreateManyWithoutOwnerInput;
  crossings?: CrossingCreateManyWithoutCrosserInput;
  rewards?: RewardCreateManyWithoutGrantorInput;
}

export interface RedemptionUpdateManyMutationInput {
  awardedAt?: DateTimeInput;
  points?: Float;
  reward?: String;
}

export interface RewardCreateInput {
  points?: Float;
  title?: String;
  text?: String;
  grantor?: UserCreateOneWithoutRewardsInput;
}

export interface UserCreateOneWithoutRewardsInput {
  create?: UserCreateWithoutRewardsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutRewardsInput {
  email: String;
  authId?: String;
  firstName: String;
  lastName: String;
  role: UserRole;
  redemptions?: RedemptionCreateManyWithoutRedeemerInput;
  geofences?: GeofenceCreateManyWithoutOwnerInput;
  crossings?: CrossingCreateManyWithoutCrosserInput;
}

export interface RewardUpdateManyMutationInput {
  points?: Float;
  title?: String;
  text?: String;
}

export interface UserCreateInput {
  email: String;
  authId?: String;
  firstName: String;
  lastName: String;
  role: UserRole;
  redemptions?: RedemptionCreateManyWithoutRedeemerInput;
  geofences?: GeofenceCreateManyWithoutOwnerInput;
  crossings?: CrossingCreateManyWithoutCrosserInput;
  rewards?: RewardCreateManyWithoutGrantorInput;
}

export interface UserUpdateInput {
  email?: String;
  authId?: String;
  firstName?: String;
  lastName?: String;
  role?: UserRole;
  redemptions?: RedemptionUpdateManyWithoutRedeemerInput;
  geofences?: GeofenceUpdateManyWithoutOwnerInput;
  crossings?: CrossingUpdateManyWithoutCrosserInput;
  rewards?: RewardUpdateManyWithoutGrantorInput;
}

export interface CrossingUpdateManyWithoutCrosserInput {
  create?:
    | CrossingCreateWithoutCrosserInput[]
    | CrossingCreateWithoutCrosserInput;
  delete?: CrossingWhereUniqueInput[] | CrossingWhereUniqueInput;
  connect?: CrossingWhereUniqueInput[] | CrossingWhereUniqueInput;
  disconnect?: CrossingWhereUniqueInput[] | CrossingWhereUniqueInput;
  update?:
    | CrossingUpdateWithWhereUniqueWithoutCrosserInput[]
    | CrossingUpdateWithWhereUniqueWithoutCrosserInput;
  upsert?:
    | CrossingUpsertWithWhereUniqueWithoutCrosserInput[]
    | CrossingUpsertWithWhereUniqueWithoutCrosserInput;
}

export interface CrossingUpdateWithWhereUniqueWithoutCrosserInput {
  where: CrossingWhereUniqueInput;
  data: CrossingUpdateWithoutCrosserDataInput;
}

export interface CrossingUpdateWithoutCrosserDataInput {
  crossedIn?: DateTimeInput;
  crossedOut?: DateTimeInput;
  geofence?: ID_Input;
  coordinates?: String;
}

export interface CrossingUpsertWithWhereUniqueWithoutCrosserInput {
  where: CrossingWhereUniqueInput;
  update: CrossingUpdateWithoutCrosserDataInput;
  create: CrossingCreateWithoutCrosserInput;
}

export interface UserUpdateManyMutationInput {
  email?: String;
  authId?: String;
  firstName?: String;
  lastName?: String;
  role?: UserRole;
}

export interface CrossingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CrossingWhereInput;
  AND?: CrossingSubscriptionWhereInput[] | CrossingSubscriptionWhereInput;
  OR?: CrossingSubscriptionWhereInput[] | CrossingSubscriptionWhereInput;
  NOT?: CrossingSubscriptionWhereInput[] | CrossingSubscriptionWhereInput;
}

export interface GeofenceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GeofenceWhereInput;
  AND?: GeofenceSubscriptionWhereInput[] | GeofenceSubscriptionWhereInput;
  OR?: GeofenceSubscriptionWhereInput[] | GeofenceSubscriptionWhereInput;
  NOT?: GeofenceSubscriptionWhereInput[] | GeofenceSubscriptionWhereInput;
}

export interface RedemptionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RedemptionWhereInput;
  AND?: RedemptionSubscriptionWhereInput[] | RedemptionSubscriptionWhereInput;
  OR?: RedemptionSubscriptionWhereInput[] | RedemptionSubscriptionWhereInput;
  NOT?: RedemptionSubscriptionWhereInput[] | RedemptionSubscriptionWhereInput;
}

export interface RewardSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RewardWhereInput;
  AND?: RewardSubscriptionWhereInput[] | RewardSubscriptionWhereInput;
  OR?: RewardSubscriptionWhereInput[] | RewardSubscriptionWhereInput;
  NOT?: RewardSubscriptionWhereInput[] | RewardSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Crossing {
  crossedIn?: DateTimeOutput;
  crossedOut?: DateTimeOutput;
  geofence?: ID_Output;
  coordinates?: String;
}

export interface CrossingPromise extends Promise<Crossing>, Fragmentable {
  crossedIn: () => Promise<DateTimeOutput>;
  crossedOut: () => Promise<DateTimeOutput>;
  geofence: () => Promise<ID_Output>;
  coordinates: () => Promise<String>;
  crosser: <T = User>() => T;
}

export interface CrossingSubscription
  extends Promise<AsyncIterator<Crossing>>,
    Fragmentable {
  crossedIn: () => Promise<AsyncIterator<DateTimeOutput>>;
  crossedOut: () => Promise<AsyncIterator<DateTimeOutput>>;
  geofence: () => Promise<AsyncIterator<ID_Output>>;
  coordinates: () => Promise<AsyncIterator<String>>;
  crosser: <T = UserSubscription>() => T;
}

export interface User {
  id: ID_Output;
  email: String;
  authId?: String;
  firstName: String;
  lastName: String;
  role: UserRole;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  authId: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  role: () => Promise<UserRole>;
  redemptions: <T = FragmentableArray<Redemption>>(
    args?: {
      where?: RedemptionWhereInput;
      orderBy?: RedemptionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  geofences: <T = FragmentableArray<Geofence>>(
    args?: {
      where?: GeofenceWhereInput;
      orderBy?: GeofenceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  crossings: <T = FragmentableArray<Crossing>>(
    args?: {
      where?: CrossingWhereInput;
      orderBy?: CrossingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  rewards: <T = FragmentableArray<Reward>>(
    args?: {
      where?: RewardWhereInput;
      orderBy?: RewardOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  authId: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<UserRole>>;
  redemptions: <T = Promise<AsyncIterator<RedemptionSubscription>>>(
    args?: {
      where?: RedemptionWhereInput;
      orderBy?: RedemptionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  geofences: <T = Promise<AsyncIterator<GeofenceSubscription>>>(
    args?: {
      where?: GeofenceWhereInput;
      orderBy?: GeofenceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  crossings: <T = Promise<AsyncIterator<CrossingSubscription>>>(
    args?: {
      where?: CrossingWhereInput;
      orderBy?: CrossingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  rewards: <T = Promise<AsyncIterator<RewardSubscription>>>(
    args?: {
      where?: RewardWhereInput;
      orderBy?: RewardOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Redemption {
  awardedAt?: DateTimeOutput;
  points?: Float;
  reward?: String;
}

export interface RedemptionPromise extends Promise<Redemption>, Fragmentable {
  awardedAt: () => Promise<DateTimeOutput>;
  points: () => Promise<Float>;
  redeemer: <T = User>() => T;
  reward: () => Promise<String>;
}

export interface RedemptionSubscription
  extends Promise<AsyncIterator<Redemption>>,
    Fragmentable {
  awardedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  points: () => Promise<AsyncIterator<Float>>;
  redeemer: <T = UserSubscription>() => T;
  reward: () => Promise<AsyncIterator<String>>;
}

export interface Geofence {
  radius?: Float;
  description?: String;
  title?: String;
  coordinates?: String;
  status?: String;
  type?: String;
  points?: Int;
  refreshRate?: Float;
}

export interface GeofencePromise extends Promise<Geofence>, Fragmentable {
  radius: () => Promise<Float>;
  description: () => Promise<String>;
  title: () => Promise<String>;
  coordinates: () => Promise<String>;
  status: () => Promise<String>;
  type: () => Promise<String>;
  points: () => Promise<Int>;
  refreshRate: () => Promise<Float>;
  owner: <T = User>() => T;
}

export interface GeofenceSubscription
  extends Promise<AsyncIterator<Geofence>>,
    Fragmentable {
  radius: () => Promise<AsyncIterator<Float>>;
  description: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  coordinates: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  points: () => Promise<AsyncIterator<Int>>;
  refreshRate: () => Promise<AsyncIterator<Float>>;
  owner: <T = UserSubscription>() => T;
}

export interface Reward {
  points?: Float;
  title?: String;
  text?: String;
}

export interface RewardPromise extends Promise<Reward>, Fragmentable {
  points: () => Promise<Float>;
  title: () => Promise<String>;
  text: () => Promise<String>;
  grantor: <T = User>() => T;
}

export interface RewardSubscription
  extends Promise<AsyncIterator<Reward>>,
    Fragmentable {
  points: () => Promise<AsyncIterator<Float>>;
  title: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  grantor: <T = UserSubscription>() => T;
}

export interface CrossingConnection {}

export interface CrossingConnectionPromise
  extends Promise<CrossingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<CrossingEdge>>() => T;
  aggregate: <T = AggregateCrossing>() => T;
}

export interface CrossingConnectionSubscription
  extends Promise<AsyncIterator<CrossingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CrossingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCrossingSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface CrossingEdge {
  cursor: String;
}

export interface CrossingEdgePromise
  extends Promise<CrossingEdge>,
    Fragmentable {
  node: <T = Crossing>() => T;
  cursor: () => Promise<String>;
}

export interface CrossingEdgeSubscription
  extends Promise<AsyncIterator<CrossingEdge>>,
    Fragmentable {
  node: <T = CrossingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCrossing {
  count: Int;
}

export interface AggregateCrossingPromise
  extends Promise<AggregateCrossing>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCrossingSubscription
  extends Promise<AsyncIterator<AggregateCrossing>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GeofenceConnection {}

export interface GeofenceConnectionPromise
  extends Promise<GeofenceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<GeofenceEdge>>() => T;
  aggregate: <T = AggregateGeofence>() => T;
}

export interface GeofenceConnectionSubscription
  extends Promise<AsyncIterator<GeofenceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GeofenceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGeofenceSubscription>() => T;
}

export interface GeofenceEdge {
  cursor: String;
}

export interface GeofenceEdgePromise
  extends Promise<GeofenceEdge>,
    Fragmentable {
  node: <T = Geofence>() => T;
  cursor: () => Promise<String>;
}

export interface GeofenceEdgeSubscription
  extends Promise<AsyncIterator<GeofenceEdge>>,
    Fragmentable {
  node: <T = GeofenceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGeofence {
  count: Int;
}

export interface AggregateGeofencePromise
  extends Promise<AggregateGeofence>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGeofenceSubscription
  extends Promise<AsyncIterator<AggregateGeofence>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RedemptionConnection {}

export interface RedemptionConnectionPromise
  extends Promise<RedemptionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<RedemptionEdge>>() => T;
  aggregate: <T = AggregateRedemption>() => T;
}

export interface RedemptionConnectionSubscription
  extends Promise<AsyncIterator<RedemptionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RedemptionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRedemptionSubscription>() => T;
}

export interface RedemptionEdge {
  cursor: String;
}

export interface RedemptionEdgePromise
  extends Promise<RedemptionEdge>,
    Fragmentable {
  node: <T = Redemption>() => T;
  cursor: () => Promise<String>;
}

export interface RedemptionEdgeSubscription
  extends Promise<AsyncIterator<RedemptionEdge>>,
    Fragmentable {
  node: <T = RedemptionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRedemption {
  count: Int;
}

export interface AggregateRedemptionPromise
  extends Promise<AggregateRedemption>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRedemptionSubscription
  extends Promise<AsyncIterator<AggregateRedemption>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RewardConnection {}

export interface RewardConnectionPromise
  extends Promise<RewardConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<RewardEdge>>() => T;
  aggregate: <T = AggregateReward>() => T;
}

export interface RewardConnectionSubscription
  extends Promise<AsyncIterator<RewardConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RewardEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRewardSubscription>() => T;
}

export interface RewardEdge {
  cursor: String;
}

export interface RewardEdgePromise extends Promise<RewardEdge>, Fragmentable {
  node: <T = Reward>() => T;
  cursor: () => Promise<String>;
}

export interface RewardEdgeSubscription
  extends Promise<AsyncIterator<RewardEdge>>,
    Fragmentable {
  node: <T = RewardSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateReward {
  count: Int;
}

export interface AggregateRewardPromise
  extends Promise<AggregateReward>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRewardSubscription
  extends Promise<AsyncIterator<AggregateReward>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUser>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = User>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CrossingSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CrossingSubscriptionPayloadPromise
  extends Promise<CrossingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Crossing>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CrossingPreviousValues>() => T;
}

export interface CrossingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CrossingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CrossingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CrossingPreviousValuesSubscription>() => T;
}

export interface CrossingPreviousValues {
  crossedIn?: DateTimeOutput;
  crossedOut?: DateTimeOutput;
  geofence?: ID_Output;
  coordinates?: String;
}

export interface CrossingPreviousValuesPromise
  extends Promise<CrossingPreviousValues>,
    Fragmentable {
  crossedIn: () => Promise<DateTimeOutput>;
  crossedOut: () => Promise<DateTimeOutput>;
  geofence: () => Promise<ID_Output>;
  coordinates: () => Promise<String>;
}

export interface CrossingPreviousValuesSubscription
  extends Promise<AsyncIterator<CrossingPreviousValues>>,
    Fragmentable {
  crossedIn: () => Promise<AsyncIterator<DateTimeOutput>>;
  crossedOut: () => Promise<AsyncIterator<DateTimeOutput>>;
  geofence: () => Promise<AsyncIterator<ID_Output>>;
  coordinates: () => Promise<AsyncIterator<String>>;
}

export interface GeofenceSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface GeofenceSubscriptionPayloadPromise
  extends Promise<GeofenceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Geofence>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GeofencePreviousValues>() => T;
}

export interface GeofenceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GeofenceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GeofenceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GeofencePreviousValuesSubscription>() => T;
}

export interface GeofencePreviousValues {
  radius?: Float;
  description?: String;
  title?: String;
  coordinates?: String;
  status?: String;
  type?: String;
  points?: Int;
  refreshRate?: Float;
}

export interface GeofencePreviousValuesPromise
  extends Promise<GeofencePreviousValues>,
    Fragmentable {
  radius: () => Promise<Float>;
  description: () => Promise<String>;
  title: () => Promise<String>;
  coordinates: () => Promise<String>;
  status: () => Promise<String>;
  type: () => Promise<String>;
  points: () => Promise<Int>;
  refreshRate: () => Promise<Float>;
}

export interface GeofencePreviousValuesSubscription
  extends Promise<AsyncIterator<GeofencePreviousValues>>,
    Fragmentable {
  radius: () => Promise<AsyncIterator<Float>>;
  description: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  coordinates: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  points: () => Promise<AsyncIterator<Int>>;
  refreshRate: () => Promise<AsyncIterator<Float>>;
}

export interface RedemptionSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface RedemptionSubscriptionPayloadPromise
  extends Promise<RedemptionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Redemption>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RedemptionPreviousValues>() => T;
}

export interface RedemptionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RedemptionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RedemptionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RedemptionPreviousValuesSubscription>() => T;
}

export interface RedemptionPreviousValues {
  awardedAt?: DateTimeOutput;
  points?: Float;
  reward?: String;
}

export interface RedemptionPreviousValuesPromise
  extends Promise<RedemptionPreviousValues>,
    Fragmentable {
  awardedAt: () => Promise<DateTimeOutput>;
  points: () => Promise<Float>;
  reward: () => Promise<String>;
}

export interface RedemptionPreviousValuesSubscription
  extends Promise<AsyncIterator<RedemptionPreviousValues>>,
    Fragmentable {
  awardedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  points: () => Promise<AsyncIterator<Float>>;
  reward: () => Promise<AsyncIterator<String>>;
}

export interface RewardSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface RewardSubscriptionPayloadPromise
  extends Promise<RewardSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Reward>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RewardPreviousValues>() => T;
}

export interface RewardSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RewardSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RewardSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RewardPreviousValuesSubscription>() => T;
}

export interface RewardPreviousValues {
  points?: Float;
  title?: String;
  text?: String;
}

export interface RewardPreviousValuesPromise
  extends Promise<RewardPreviousValues>,
    Fragmentable {
  points: () => Promise<Float>;
  title: () => Promise<String>;
  text: () => Promise<String>;
}

export interface RewardPreviousValuesSubscription
  extends Promise<AsyncIterator<RewardPreviousValues>>,
    Fragmentable {
  points: () => Promise<AsyncIterator<Float>>;
  title: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = User>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValues>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  email: String;
  authId?: String;
  firstName: String;
  lastName: String;
  role: UserRole;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  authId: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  role: () => Promise<UserRole>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  authId: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<UserRole>>;
}

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Type Defs
 */

export const prisma: Prisma;
